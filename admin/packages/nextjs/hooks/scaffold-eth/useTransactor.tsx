import { TransactionReceipt, TransactionRequest, TransactionResponse } from "@ethersproject/abstract-provider";
import { SendTransactionResult } from "@wagmi/core";
import { Signer } from "ethers";
import { Deferrable } from "ethers/lib/utils";
import { useSigner } from "wagmi";
import { getParsedEthersError } from "~~/components/scaffold-eth";
import { getBlockExplorerTxLink, notification } from "~~/utils/scaffold-eth";

type TTransactionFunc = (
    tx: Promise<SendTransactionResult> | Deferrable<TransactionRequest> | undefined,
    options?: {
        onBlockConfirmation?: (txnReceipt: TransactionReceipt) => void;
        blockConfirmations?: number;
    },
) => Promise<Record<string, any> | undefined>;

/**
 * Custom notification content for TXs.
 */
const TxnNotification = ({ message, blockExplorerLink }: { message: string; blockExplorerLink?: string }) => {
    return (
        <div className={`flex flex-col ml-1 cursor-default`}>
            <p className="my-0">{message}</p>
            {blockExplorerLink && blockExplorerLink.length > 0 ? (
                <a href={blockExplorerLink} target="_blank" rel="noreferrer" className="block underline text-md">
                    check out transaction
                </a>
            ) : null}
        </div>
    );
};

/**
 * Runs TXs showing UI feedback.
 * @param _signer
 * @dev If signer is provided => dev wants to send a raw tx.
 */
export const useTransactor = (_signer?: Signer): TTransactionFunc => {
    let signer = _signer;
    const { data } = useSigner();
    if (signer === undefined && data) {
        signer = data;
    }

    const result: TTransactionFunc = async (tx, options) => {
        if (!signer) {
            notification.error("Wallet/Signer not connected");
            console.error("‚ö°Ô∏è ~ file: useTransactor.tsx ~ error");
            return;
        }

        let notificationId = null;
        let transactionResponse: SendTransactionResult | TransactionResponse | undefined;
        try {
            const provider = signer.provider;
            const network = await provider?.getNetwork();

            notificationId = notification.loading(<TxnNotification message="Awaiting for user confirmation" />);
            if (tx instanceof Promise) {
                // Tx is already prepared by the caller
                transactionResponse = await tx;
            } else if (tx != null) {
                transactionResponse = await signer.sendTransaction(tx);
            } else {
                throw new Error("Incorrect transaction passed to transactor");
            }
            notification.remove(notificationId);

            const blockExplorerTxURL = network ? getBlockExplorerTxLink(network, transactionResponse.hash) : "";

            notificationId = notification.loading(
                <TxnNotification
                    message="Waiting for transaction to complete."
                    blockExplorerLink={blockExplorerTxURL}
                />,
            );

            const transactionReceipt = await transactionResponse.wait(options?.blockConfirmations);
            notification.remove(notificationId);

            notification.success(
                <TxnNotification
                    message="Transaction completed successfully!"
                    blockExplorerLink={blockExplorerTxURL}
                />,
                {
                    icon: "üéâ",
                },
            );

            if (options?.onBlockConfirmation) options.onBlockConfirmation(transactionReceipt);
        } catch (error: any) {
            if (notificationId) {
                notification.remove(notificationId);
            }
            // TODO handle error properly
            console.error("‚ö°Ô∏è ~ file: useTransactor.ts ~ error", error);
            const message = getParsedEthersError(error);
            notification.error(message);
        }

        return transactionResponse;
    };

    return result;
};
