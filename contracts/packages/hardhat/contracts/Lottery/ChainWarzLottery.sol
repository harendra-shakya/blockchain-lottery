// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * Interface for Blacklist manager
 */
interface IBlackListManager {
    function isBlackListed(address _player) external view returns (bool);
}

interface IFundManager {
    function decreaseBalanceByContract(uint256 battleId, address user, uint256 amount) external;
}

/**
 * @title Chainwarz Lottery
 * @notice This lottery consumes VRF v1 from Chainlink.
 * It has a role of "operator". The "operator" role is used by a backend app to make calls to manage lottery.
 * @dev It saves the player wallet and the current entries count in an ordered array.
 * Buying entries has a complexity of O(1).
 * For calculating the winner, a normalized random number is generated from the huge random number generated by Chainlink.
 * The normalized random number is generated by using the module method and adding 1 to have a random number from 1 to entriesCount.
 * The next step is to perform a binary search on the ordered array to get the player. The complexity of this step is O(log n).
 * For example, if the ordered array is:
 * 0 -> { 1, player1} as player1 buys 1 entry
 * 1 -> {51, player2} as player2 buys 50 entries
 * 2 -> {52, player3} as player3 buys 1 entry
 * 3 -> {53, player4} as player4 buys 1 entry
 * 4 -> {153, player5} as player5 buys 100 entries
 *
 * The endBattle method performs a binary search on that sorted array to get the upper bound.
 *
 * If the random number generated is 150, the winner is player5. If the random number is 20, the winner is player2.
 */
contract ChainWarzLottery is ReentrancyGuard, VRFConsumerBase, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter public jackpotBattleId;

    ////////// CHAINLINK VRF v1 /////////////////

    bytes32 internal keyHash; // chainlink keyHash
    uint256 internal fee; // fee paid in LINK to chainlink. 0.1 on testnet, 2 on mainnet

    struct BattleInfo {
        uint256 id; // battleId
        uint256 size; // length of the entries array of that battle
    }

    // maps the requestId created by Chainlink with the battle info passed as a parameter when calling getRandomNumber()
    mapping(bytes32 => BattleInfo) private chainlinkBattleInfo;

    /////////////// END CHAINKINK VRF V1 //////////////

    address payable public treasuryAddress;
    address public operatorAddress;
    address public injectorAddress;

    address payable public reserveFundAddress;
    address payable public stakersAddress;
    address public fundManaderAddress;

    // contract that contains the blacklist addresses
    IBlackListManager blackListManager;

    uint256 public stakersReward = 1000; // 10%
    uint256 public constant MAX_TREASURY_FEE = 1000; // 10%
    uint256 public constant MAX_JACKPOT_BATTLE_CONTRIBUTION = 1000; // 10%

    // Every battle has an array of price structures (max size = 5) with different prices for the different
    // entries bought.
    struct PriceStructure {
        uint256 id;
        uint256 numEntries;
        uint256 price;
    }
    mapping(uint256 => PriceStructure[5]) private prices;

    // In order to calculate the winner, this struct saves the data for each bought entry.
    struct Entries {
        uint256 currentEntriesLength; // current amount of entries bought in the battle
        address player; // wallet address of the player
    }

    // Every battle has a sorted array of entries. Each element is created when calling either buyFighter or giveBatchEntriesForFree or createEntries.
    mapping(uint256 => Entries[]) private entriesList;

    struct FreeEntries {
        uint128 freeEntries; // amount of free entries for weekly jackpot
        bool claimed; // entries claimed or not
    }

    mapping(uint256 => mapping(address => FreeEntries)) private weeklyFreeEntries;

    // per raffle free entry claimed or not
    mapping(uint256 => mapping(address => bool)) private isDailyFreeEntryClaimed;

    struct WeeklyJackpot {
        bool started; // started or not
        bool finished; // finished or not
        uint256 amountCollected; // amountCollected
    }

    mapping(uint256 => WeeklyJackpot) private weeklyJackpotBattles;

    // Main battle data struct
    struct BattleStruct {
        Status status;
        uint256 maxEntries;
        address winner;
        bool isJackpotBattle;
        uint256 randomNumber;
        uint256 amountCollected;
        uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%
        uint256 weeklyJackpotBattleBps;
        uint256 entriesLength;
        uint256 cancellingDate;
        address[] nftCollectionWhitelist; // Addresses of the required NFTs. This array will be empty if no NFT is required to buy.
    }

    BattleStruct[] private battles;

    // contains the number of entries each user has bought to prevent abuse, as well as the claiming info.
    struct ClaimData {
        uint256 numEntriesPerUser;
        uint256 amountSpentInWeis;
        bool claimed;
    }

    // hash of (battleId, player) => claimsData
    mapping(bytes32 => ClaimData) private claimsData;

    mapping(bytes32 => address) private requiredNFTWallets;

    enum Status {
        Pending,
        Open,
        Close,
        Cancelled
    }

    modifier isValidUser() {
        require(!_isContract(msg.sender), "Contract not allowed"); // notContract
        require(!isBlackListed(msg.sender), "Blacklisted!"); // notBlackListed
        _;
    }

    modifier onlyOperator() {
        require(msg.sender == operatorAddress, "Not operator");
        _;
    }

    modifier onlyOwnerOrInjector() {
        require((msg.sender == owner()) || (msg.sender == injectorAddress), "Not owner or injector");
        _;
    }

    event BattleStarted(uint256 indexed battleId);
    event BattleEnded(bytes32 indexed requestId, uint256 indexed battleId, uint256 amountCollected);
    event FightersPurchase(uint256 indexed battleId, address indexed buyer, uint256 currentSize, uint256 entriesBought);
    event FreeEntry(
        uint256 _battleId,
        address[] _players,
        uint[] _numEntries,
        uint256 totalAmountOfEntries,
        uint256 currentSize
    );
    event BattleCancelled(uint256 indexed battleId, uint256 amountCollected);
    event PrizeTransferred(
        uint256 indexed battleId,
        uint256 treasuryFee,
        uint256 weeklyJackpotBattleBps,
        uint256 stakersReward,
        uint256 indexed winnerPrize
    );
    event RemainingFundsTransferred(uint256 indexed battleId, uint256 amountInWeis);
    event Refund(uint256 indexed battleId, uint256 amountInWeis, address indexed player);
    event EntryCancelled(uint256 indexed battleId, uint256 amountOfEntriesCanceled, address player);
    event RandomNumberCreated(uint256 indexed id, uint256 randomNumber, uint256 normalizedRandomNumber);
    event BattleInjection(uint256 indexed battleId, uint256 injectedAmount);
    event StakersRewardChanged(uint256 indexed newStakersReward);

    constructor(
        address _blacklistManager,
        address _vrfCoordinator,
        address _linkToken,
        address _treasuryAddress,
        address _operatorAddress,
        address _injectorAddress,
        address _reserveFundAddress,
        bytes32 _keyHash,
        bool _mainnetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        reserveFundAddress = payable(_reserveFundAddress);
        operatorAddress = _operatorAddress;
        injectorAddress = _injectorAddress;
        keyHash = _keyHash;
        if (_mainnetFee == true)
            fee = 2 * 10 ** 18; // on mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK on Goerli

        blackListManager = IBlackListManager(_blacklistManager);
        treasuryAddress = payable(_treasuryAddress);
    }

    /**
     * @dev This method is called by players to buy entries for a battle using the specified price structure (_priceId parameter).
     * The number of entries assigned to the player depends on the price structure. The method also checks if the maximum number of entries has been reached.
     * As this method is payable, the amount paid by the user is contained in msg.value.
     * @notice If requiredNFTs were set by the operator when creating the battle, only owners of NFTs in that collection can call this method. This is used for special battles.
     * @param _battleId: ID of the battle
     * @param _priceId: ID of the price structure
     * @param _collection: collection of tokenId used and is not used if there are no required NFTs for battle
     * @param _tokenIdUsed: Specifies ID of token used in private battles and cannot be reused in same battle to prevent abuse
     */
    function buyFighter(
        uint256 _battleId,
        uint256 _priceId,
        address _collection,
        uint256 _tokenIdUsed
    ) external payable nonReentrant isValidUser {
        BattleStruct storage battle = battles[_battleId];

        if (!isDailyFreeEntryClaimed[_battleId][msg.sender] && !battle.isJackpotBattle) {
            ++weeklyFreeEntries[jackpotBattleId.current()][msg.sender].freeEntries;
            isDailyFreeEntryClaimed[_battleId][msg.sender] = true;
        }

        // * If the battle requires an nft
        if (battle.nftCollectionWhitelist.length > 0) {
            bool hasRequiredCollection = false;
            for (uint256 i; i < battle.nftCollectionWhitelist.length; ++i) {
                if (battle.nftCollectionWhitelist[i] == _collection) {
                    hasRequiredCollection = true;
                    break;
                }
            }
            require(hasRequiredCollection == true, "Not in required collection");
            IERC721 requiredNFT = IERC721(_collection);
            require(requiredNFT.ownerOf(_tokenIdUsed) == msg.sender, "Not the owner of tokenId");
            bytes32 hashRequiredNFT = keccak256(abi.encode(_collection, _battleId, _tokenIdUsed));
            // check the tokenId has not been using yet in the battle, to avoid abuse
            if (requiredNFTWallets[hashRequiredNFT] == address(0)) {
                requiredNFTWallets[hashRequiredNFT] = msg.sender;
            } else require(requiredNFTWallets[hashRequiredNFT] == msg.sender, "tokenId used");
        }

        require(msg.sender != address(0), "msg.sender is null"); // 37
        require(_priceId > 0, "_priceId is 0");
        require(battle.status == Status.Open, "Battle is not open"); // 1808
        PriceStructure memory priceStruct = getPriceStructForId(_battleId, _priceId);
        require(priceStruct.numEntries > 0, "numEntries not supported");
        require(msg.value == priceStruct.price, "msg.value must be equal to the price"); // 1722

        bytes32 hash = keccak256(abi.encode(msg.sender, _battleId));
        // check there are enough entries left for this particular user
        if (battle.maxEntries > 0) {
            require(
                claimsData[hash].numEntriesPerUser + priceStruct.numEntries <= battle.maxEntries,
                "Bought too many entries"
            );
        }

        Entries memory entryBought = Entries({
            player: msg.sender,
            currentEntriesLength: battle.entriesLength + priceStruct.numEntries
        });
        entriesList[_battleId].push(entryBought);

        battle.amountCollected += msg.value; // 6917 gas
        // update the field entriesLength, used in frontend to avoid making extra calls
        battle.entriesLength += priceStruct.numEntries;
        //update claim data
        claimsData[hash].numEntriesPerUser += priceStruct.numEntries;
        claimsData[hash].amountSpentInWeis += msg.value;

        emit FightersPurchase(_battleId, msg.sender, battle.entriesLength, priceStruct.numEntries); // 2377
    }

    /**
     * @dev This function allows players to claim their weekly free entries for a specified battle (_battleId).
     * The function checks if the player has already claimed their free entries and if the battle is open.
     * If both conditions are met, the player's free entries are added to the battle's entries list and marked as claimed.
     * @param _battleId ID of the battle
     */
    function claimWeeklyFreeEntries(uint256 _battleId) external nonReentrant isValidUser {
        require(!weeklyFreeEntries[jackpotBattleId.current()][msg.sender].claimed, "Free entries already claimed");
        BattleStruct storage battle = battles[_battleId];
        require(battle.status == Status.Open, "Battle is not open");
        require(battle.isJackpotBattle, "Not a Jackpot Battle");

        bytes32 hash = keccak256(abi.encode(msg.sender, _battleId));
        uint256 _freeEntries = weeklyFreeEntries[jackpotBattleId.current()][msg.sender].freeEntries;

        if (battle.maxEntries > 0) {
            require(claimsData[hash].numEntriesPerUser + _freeEntries <= battle.maxEntries, "Bought too many entries");
        }

        Entries memory entryBought = Entries({
            player: msg.sender,
            currentEntriesLength: battle.entriesLength + _freeEntries
        });

        entriesList[_battleId].push(entryBought);

        weeklyFreeEntries[jackpotBattleId.current()][msg.sender].claimed = true;

        battle.entriesLength += _freeEntries;
        claimsData[hash].numEntriesPerUser += _freeEntries;
    }

    /**
     * @dev This function allows players to buy a fighter and claim their weekly free entries for a specified battle (_battleId) using the specified price structure (_priceId).
     * The function checks if the player has already claimed their free entries and if they are blacklisted.
     * If both conditions are met, the player's free entries are incremented and marked as claimed.
     * If the battle requires an NFT, the function checks if the player has a required collection and is the owner of the specified token (_tokenIdUsed).
     * The function also checks if the token has already been used in the battle to prevent abuse.
     * @param _battleId ID of the battle
     * @param _priceId ID of the price structure
     * @param _collection Collection of tokenId used and is not used if there are no required NFTs for battle
     * @param _tokenIdUsed Specifies ID of token used in private battles and cannot be reused in same battle to prevent abuse
     */
    function buyFighterAndGetWeeklyFreeEntries(
        uint256 _battleId,
        uint256 _priceId,
        address _collection,
        uint256 _tokenIdUsed
    ) external payable nonReentrant isValidUser {
        require(blackListManager.isBlackListed(msg.sender) == false, "Blacklisted!");

        BattleStruct storage battle = battles[_battleId];

        if (!isDailyFreeEntryClaimed[_battleId][msg.sender] && !battle.isJackpotBattle) {
            ++weeklyFreeEntries[jackpotBattleId.current()][msg.sender].freeEntries;
            isDailyFreeEntryClaimed[_battleId][msg.sender] = true;
        }

        // * If the battle requires an nft
        if (battle.nftCollectionWhitelist.length > 0) {
            bool hasRequiredCollection = false;
            for (uint256 i; i < battle.nftCollectionWhitelist.length; ++i) {
                if (battle.nftCollectionWhitelist[i] == _collection) {
                    hasRequiredCollection = true;
                    break;
                }
            }
            require(hasRequiredCollection == true, "Not in required collection");
            IERC721 requiredNFT = IERC721(_collection);
            require(requiredNFT.ownerOf(_tokenIdUsed) == msg.sender, "Not the owner of tokenId");
            bytes32 hashRequiredNFT = keccak256(abi.encode(_collection, _battleId, _tokenIdUsed));
            // check the tokenId has not been using yet in the battle, to avoid abuse
            if (requiredNFTWallets[hashRequiredNFT] == address(0)) {
                requiredNFTWallets[hashRequiredNFT] = msg.sender;
            } else require(requiredNFTWallets[hashRequiredNFT] == msg.sender, "tokenId used");
        }

        require(msg.sender != address(0), "msg.sender is null"); // 37
        require(_priceId > 0, "_priceId is 0");
        require(battle.status == Status.Open, "Battle is not open"); // 1808
        PriceStructure memory priceStruct = getPriceStructForId(_battleId, _priceId);
        require(priceStruct.numEntries > 0, "numEntries not supported");
        require(msg.value == priceStruct.price, "msg.value must be equal to the price"); // 1722

        bytes32 hash = keccak256(abi.encode(msg.sender, _battleId));
        // check there are enough entries left for this particular user
        if (battle.maxEntries > 0) {
            require(
                claimsData[hash].numEntriesPerUser + priceStruct.numEntries <= battle.maxEntries,
                "Bought too many entries"
            );
        }

        uint256 _weeklyFreeEntries;

        // free weekly entries
        if (battle.isJackpotBattle && !weeklyFreeEntries[jackpotBattleId.current()][msg.sender].claimed) {
            _weeklyFreeEntries = weeklyFreeEntries[jackpotBattleId.current()][msg.sender].freeEntries;

            weeklyFreeEntries[jackpotBattleId.current()][msg.sender].claimed = true;
        }

        Entries memory entryBought = Entries({
            player: msg.sender,
            currentEntriesLength: battle.entriesLength + priceStruct.numEntries + _weeklyFreeEntries
        });
        entriesList[_battleId].push(entryBought);

        battle.amountCollected += msg.value; // 6917 gas
        // update the field entriesLength, used in frontend to avoid making extra calls
        battle.entriesLength += priceStruct.numEntries + _weeklyFreeEntries;
        //update claim data
        claimsData[hash].numEntriesPerUser += priceStruct.numEntries + _weeklyFreeEntries;
        claimsData[hash].amountSpentInWeis += msg.value;

        emit FightersPurchase(_battleId, msg.sender, battle.entriesLength, priceStruct.numEntries); // 2377
    }

    /**
     * @dev This function is called by the operator to give a user gasless entries.
     * All the necessary checks and validations are assumed to happen in the backend application.
     * @param _battleId The ID of the battle.
     * @param _amountOfEntries The number of entries to be given to the user.
     * @param _player The address of the user receiving the gasless entries.
     * @param price The price associated with each entry.
     */
    function createEntries(
        uint256 _battleId,
        uint256 _amountOfEntries,
        address _player,
        uint256 price
    ) external nonReentrant onlyOperator {
        require(_amountOfEntries > 0, "Invalid entries");
        require(price > 0, "Invalid price");

        BattleStruct storage battle = battles[_battleId];

        Entries memory entryBought = Entries({
            player: _player,
            currentEntriesLength: battle.entriesLength + _amountOfEntries
        });

        entriesList[_battleId].push(entryBought);

        battle.entriesLength += _amountOfEntries;

        bytes32 hash = keccak256(abi.encode(_player, _battleId));
        claimsData[hash].numEntriesPerUser += _amountOfEntries;

        IFundManager(fundManaderAddress).decreaseBalanceByContract(_battleId, _player, price);

        emit FightersPurchase(_battleId, _player, battle.entriesLength, _amountOfEntries); // 2377
    }

    /**
     * @dev This method allows the operator to add free entries to a battle for specified players.
     * The number of entries assigned to each player is specified by _numEntries and multiple entries can be assigned to a user unless they have already reached the maximum limit of entries per user.
     * @param _battleId: ID of the battle
     * @param _amountOfEntries: number of entries for players
     * @param _players: Specifies an array of addresses corresponding to the wallets of users that won free entries
     * Note: Only the operator can call this method.
     */
    function giveBatchEntriesForFree(
        uint256 _battleId,
        uint256[] memory _amountOfEntries,
        address[] memory _players
    ) external onlyOperator nonReentrant {
        require(_amountOfEntries.length == _players.length, "Invalid input lengths");
        require(_amountOfEntries.length > 0, "Array length is 0");

        BattleStruct storage battle = battles[_battleId];
        require(battle.status == Status.Open, "Battle is not open");

        uint totalAmountOfEntries;

        for (uint256 i; i < _amountOfEntries.length; ++i) {
            address player = _players[i];
            uint256 amountOfEntries = _amountOfEntries[i];
            bytes32 hash = keccak256(abi.encode(player, _battleId));

            Entries memory entryBought = Entries({
                player: player,
                currentEntriesLength: battle.entriesLength + amountOfEntries
            });
            entriesList[_battleId].push(entryBought);

            totalAmountOfEntries += amountOfEntries;

            // update claim data
            claimsData[hash].numEntriesPerUser += amountOfEntries;
        }

        // update the field entriesLength
        battle.entriesLength += totalAmountOfEntries;

        emit FreeEntry(_battleId, _players, _amountOfEntries, totalAmountOfEntries, battles[_battleId].entriesLength);
    }

    function giveBatchEntries(uint256 _battleId, address[] memory _freePlayers) external nonReentrant onlyOperator {
        require(battles[_battleId].status == Status.Open, "Raffle is not in accepted");

        uint256 freePlayersLength = _freePlayers.length;
        uint256 validPlayersCount = 0;
        for (uint256 i = 0; i < freePlayersLength; i++) {
            address entry = _freePlayers[i];
            if (
                claimsData[keccak256(abi.encode(entry, _battleId))].numEntriesPerUser + 1 <=
                battles[_battleId].maxEntries
            ) {
                // add a new element to the entriesBought array.
                // as this method only adds 1 entry per call, the amountbought is always 1
                Entries memory entryBought = Entries({
                    player: entry,
                    currentEntriesLength: battles[_battleId].entriesLength + 1
                });
                entriesList[_battleId].push(entryBought);
                claimsData[keccak256(abi.encode(entry, _battleId))].numEntriesPerUser++;

                ++validPlayersCount;
            }
        }

        battles[_battleId].entriesLength = battles[_battleId].entriesLength + validPlayersCount;

        // emit FreeEntry(_battleId, _freePlayers, freePlayersLength, battles[_battleId].entriesLength);
    }

    /**
     * @dev This method creates a new battle and adds it to the battles array, called by operator
     * @param _maxEntriesPerUser: maximum number of entries a user can have to avoid whales
     * @param _prices: Specifies an array of prices and the number of entries a customer can purchase
     * @param _treasuryFeeInBps: commission for the platform in basis points
     * @param _weeklyJackpotBattleBps: contribution to jackpot weekly battke in basis points
     * @param _nftCollectionWhitelist: Specifies an array of required collections to participate in the battle. If there is no collection requirement, this parameter should be empty.
     * @return Returns the ID of the created battle.
     */
    function startBattle(
        uint256 _maxEntriesPerUser,
        PriceStructure[] calldata _prices,
        uint256 _treasuryFeeInBps,
        uint256 _weeklyJackpotBattleBps,
        address[] calldata _nftCollectionWhitelist,
        bool _isJackpotBattle
    ) external onlyOperator returns (uint256) {
        require(_treasuryFeeInBps <= MAX_TREASURY_FEE, "treasury fee too high");
        require(_weeklyJackpotBattleBps <= MAX_JACKPOT_BATTLE_CONTRIBUTION, "WB contribution too high");

        if (_isJackpotBattle) {
            require(!weeklyJackpotBattles[jackpotBattleId.current()].started, "Last Jackpot Battle not finished yet");
            weeklyJackpotBattles[jackpotBattleId.current()].started = true;
        }

        BattleStruct memory battle = BattleStruct({
            status: Status.Open,
            maxEntries: _maxEntriesPerUser,
            winner: address(0),
            isJackpotBattle: _isJackpotBattle,
            randomNumber: 0,
            amountCollected: 0,
            treasuryFee: _treasuryFeeInBps,
            weeklyJackpotBattleBps: _weeklyJackpotBattleBps,
            entriesLength: 0,
            cancellingDate: 0,
            nftCollectionWhitelist: _nftCollectionWhitelist
        });

        battles.push(battle);

        require(_prices.length > 0, "No prices");

        for (uint256 i = 0; i < _prices.length; i++) {
            require(_prices[i].numEntries > 0, "numEntries is 0");

            PriceStructure memory p = PriceStructure({
                id: _prices[i].id,
                numEntries: _prices[i].numEntries,
                price: _prices[i].price
            });

            prices[battles.length - 1][i] = p;
        }

        emit BattleStarted(battles.length - 1);

        return battles.length - 1;
    }

    /**
     * @notice This method returns the price structure for a specified battle and price ID.
     * @param _battleId: ID of the battle
     * @param _priceId: ID of the price structure
     * @return Returns the price structure for that particular battle and price ID.
     * @dev This method is used in the frontend to display the price structure.
     *
     * Example of a price structure:
     * 1 ticket: 0.02
     * 5 tickets: 0.018 (10% discount)
     * 10 tickets: 0.16 (20% discount)
     * 25 tickets: 0.35 (30% discount)
     * 50 tickets: 0.6 (40% discount)
     */
    function getPriceStructForId(uint256 _battleId, uint256 _priceId) internal view returns (PriceStructure memory) {
        for (uint256 i = 0; i < 5; i++) {
            if (prices[_battleId][i].id == _priceId) {
                return prices[_battleId][i];
            }
        }
        return PriceStructure({id: 0, numEntries: 0, price: 0});
    }

    /**
     * @notice This method returns the price for a specified battle and price ID.
     * @dev This method iterates through the prices array for a given battle ID and returns the price if it matches with the given price ID.
     * @param _battleId: ID of the battle
     * @param _priceId: ID of the price
     * @return uint256: The price for a specified battle and price ID. Returns 0 if no matching price is found.
     */
    function getPrice(uint256 _battleId, uint256 _priceId) internal view returns (uint256) {
        for (uint256 i = 0; i < 5; i++) {
            if (prices[_battleId][i].id == _priceId) {
                return prices[_battleId][i].price;
            }
        }
        return 0;
    }

    /**
     * @notice This method is called by the smart contract to get a random number.
     * @dev This method is used to generate a random number for a specified battle using Chainlink.
     * @param _id: ID of the battle
     * @param _entriesSize: length of the entries array for that battle
     */
    function getRandomNumber(uint256 _id, uint256 _entriesSize) internal returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");
        bytes32 result = requestRandomness(keyHash, fee);
        // result is the requestId generated by chainlink. It is saved in a map linked to the param id
        chainlinkBattleInfo[result] = BattleInfo({id: _id, size: _entriesSize});
        return result;
    }

    /**
     * @notice This method is a callback function used by the VRF Coordinator and is called by Chainlink to generate a random number.
     * @dev The random number generated is normalized to the size of the entries array.
     * @param requestId: ID generated previously by the getRandomNumber method from Chainlink
     * @param randomness: large random number generated by Chainlink
     */
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        // randomness is the actual random number. Now extract from the aux map the original param id of the call
        BattleInfo memory battleInfo = chainlinkBattleInfo[requestId];
        // save the random number on the map with the original id as key
        uint256 normalizedRandomNumber = (randomness % battleInfo.size) + 1;

        // send the event with the original id and the random number
        emit RandomNumberCreated(battleInfo.id, randomness, normalizedRandomNumber);

        transferPrize(battleInfo.id, normalizedRandomNumber);
    }

    /**
     * @notice This helper method returns the winner address of a specified battle.
     * @param _battleId: ID of the battle
     * @param _normalizedRandomNumber: random number generated by Chainlink
     * @return Returns the wallet address that won the battle.
     * @dev This method uses a binary search on a sorted array to retrieve the winner.
     * If the winner candidate is blacklisted, it loops through to find a non-blacklisted candidate.
     */
    function getWinnerAddressFromRandom(
        uint256 _battleId,
        uint256 _normalizedRandomNumber
    ) public view returns (address) {
        uint256 position = findUpperBound(entriesList[_battleId], _normalizedRandomNumber);

        address candidate = entriesList[_battleId][position].player;
        // general case
        if (candidate != address(0)) return candidate;
        // special case. The user is blacklisted, so try next on the left until find a non-blacklisted
        else {
            bool ended = false;
            uint256 i = position;
            while (ended == false && entriesList[_battleId][i].player == address(0)) {
                if (i == 0) i = entriesList[_battleId].length - 1;
                else i = i - 1;
                // we came to the beginning without finding a non blacklisted player
                if (i == position) ended == true;
            }
            require(!ended, "All users blacklisted");
            return entriesList[_battleId][i].player;
        }
    }

    /**
     * @param array sorted array of Entries. CurrentEntriesLength is the numeric field used to sort
     * @param element uint256 to find. Goes from 1 to entriesLength
     * @dev based on openzeppelin code (v4.0), modified to use an array of Entries
     * Searches a sorted array and returns the first index that contains a value greater or equal to element.
     * If no such index exists (i.e. all values in the array are strictly less than element), the array length is returned. Time complexity O(log n).
     * array is expected to be sorted in ascending order, and to contain no repeated elements.
     * https://docs.openzeppelin.com/contracts/3.x/api/utils#Arrays-findUpperBound-uint256---uint256-
     */
    function findUpperBound(Entries[] storage array, uint256 element) internal view returns (uint256) {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = Math.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid].currentEntriesLength > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1].currentEntriesLength == element) {
            return low - 1;
        } else {
            return low;
        }
    }

    /**
     * @notice This method sets the winner and transfers funds for a specified battle.
     * @param _battleId: ID of the battle
     * @param _normalizedRandomNumber: Index of the array that contains the winner of the battle, generated by Chainlink
     * @dev This method is called by Chainlink's callback function to transfer prize and stakersReward.
     */
    function transferPrize(uint256 _battleId, uint256 _normalizedRandomNumber) internal nonReentrant {
        BattleStruct storage battle = battles[_battleId];
        require(battle.status == Status.Close, "Battle in wrong status");

        battle.randomNumber = _normalizedRandomNumber;
        battle.winner = getWinnerAddressFromRandom(_battleId, _normalizedRandomNumber);

        uint256 treasuryFee = (battle.amountCollected * battle.treasuryFee) / 10000;

        uint256 weeklyJackpotAmount = (battle.amountCollected * battle.weeklyJackpotBattleBps) / 10000;

        uint256 _stakersReward = (battle.amountCollected * stakersReward) / 10000;

        uint256 winnerPrize = (battle.amountCollected - (treasuryFee + weeklyJackpotAmount + _stakersReward));

        if (battle.isJackpotBattle) {
            winnerPrize += weeklyJackpotBattles[jackpotBattleId.current()].amountCollected;
        }

        // * Winner
        (bool sentPrize, ) = battle.winner.call{value: winnerPrize}("");
        require(sentPrize, "Failed to send Prize Ether");

        if (stakersAddress == address(0)) {
            (bool sent, ) = reserveFundAddress.call{value: _stakersReward}("");
            require(sent, "Failed send Eth to Reserve Fund Address");
        } else {
            // * Stakers
            (bool sent, ) = stakersAddress.call{value: _stakersReward}("");
            require(sent, "Failed send Eth to stakersAddress");
        }

        // * Platform
        (bool sent2, ) = treasuryAddress.call{value: treasuryFee}("");
        require(sent2, "Failed send Eth to treasuryAddress");

        // * Weekly jackpot
        if (battle.isJackpotBattle) {
            (bool sent3, ) = reserveFundAddress.call{value: weeklyJackpotAmount}("");
            require(sent3, "Failed send Eth to Reserve Fund Address");

            weeklyJackpotBattles[jackpotBattleId.current()].finished = true;
            jackpotBattleId.increment();
        } else {
            weeklyJackpotBattles[jackpotBattleId.current()].amountCollected += weeklyJackpotAmount;
        }

        emit PrizeTransferred(_battleId, treasuryFee, weeklyJackpotAmount, _stakersReward, winnerPrize);
    }

    /**
     * @notice This method allows the operator to finish a battle.
     * @param _battleId: ID of the battle
     * @dev This method triggers Chainlink's VRF1 consumer and generates a random number that is normalized.
     */
    function endBattle(uint256 _battleId) external onlyOperator {
        BattleStruct storage battle = battles[_battleId];
        require(battle.status == Status.Open, "Battle not open");
        battle.status = Status.Close;

        // this call trigers the VRF v1 process from Chainlink
        bytes32 requestId = getRandomNumber(_battleId, battle.entriesLength);

        emit BattleEnded(requestId, _battleId, battle.amountCollected);
    }

    /**
     * @notice This method allows the operator to cancel a specified battle.
     * @param _battleId: ID of the battle
     * @dev Users have 30 days to claim their refund after a battle has been canceled by the operator.
     */
    function cancelBattle(uint256 _battleId) external onlyOperator {
        BattleStruct storage battle = battles[_battleId];

        // Don't cancel twice, or cancel an already ended battle
        require(battle.status == Status.Open, "Battle not open");

        battle.status = Status.Cancelled;
        battle.cancellingDate = block.timestamp;

        emit BattleCancelled(_battleId, battle.amountCollected);
    }

    /**
     * @notice Check if an address is a contract
     */
    function _isContract(address _addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }

    /**
     * @notice Injects funds into a battle
     * @param _battleId The ID of the battle to inject funds into
     */
    function injectFunds(uint256 _battleId) external payable {
        require(msg.value > 0, "Eth not sent");
        require(battles[_battleId].status == Status.Open, "Battle not open");
        battles[_battleId].amountCollected += msg.value;
        emit BattleInjection(_battleId, msg.value);
    }

    /**
     * @notice This method voids player entries for a specified battle.
     * @param _battleId: Specifies the ID of the battle
     * @param _entriesToCancel: Specifies an array containing the indixes of entries to cancel (0-based)
     * @param _player: Specifies the player who owns the entry to be voided
     * Although it has a cost in gas, it makes Chainlink's callback cheaper in gas.
     */
    function cancelEntry(
        uint256 _battleId,
        uint256[] calldata _entriesToCancel,
        address _player
    ) external onlyOperator {
        uint256 totalEntriesCancelled = 0;
        for (uint256 i = 0; i < _entriesToCancel.length; i++) {
            Entries storage entry = entriesList[_battleId][_entriesToCancel[i]];

            require(entry.player == _player, "Entry did not belong to player");

            entry.player = address(0);

            uint256 previousTotalEntriesLength;
            if (_entriesToCancel[i] == 0) previousTotalEntriesLength = 0;
            else previousTotalEntriesLength = entriesList[_battleId][_entriesToCancel[i] - 1].currentEntriesLength;
            totalEntriesCancelled += entry.currentEntriesLength - previousTotalEntriesLength;
        }
        emit EntryCancelled(_battleId, totalEntriesCancelled, _player);
    }

    /**
     * @notice This method allows a player to claim a refund for a specified battle.
     * @param _battleId: Specifies the ID of the battle
     * @dev Players can claim a refund during the first 30 days after a battle has been canceled.
     * The "ClaimsData" map saves how much each player spent on that battle since they could have bought several entries.
     */
    function claimRefund(uint256 _battleId) external nonReentrant {
        BattleStruct storage battle = battles[_battleId];
        require(battle.status == Status.Cancelled, "wrong status");
        require(block.timestamp <= battle.cancellingDate + 30 days, "claim time expired");

        ClaimData storage claimData = claimsData[keccak256(abi.encode(msg.sender, _battleId))];

        require(claimData.claimed == false, "already refunded");

        battle.amountCollected = battle.amountCollected - claimData.amountSpentInWeis;

        claimData.claimed = true;
        (bool sent, ) = msg.sender.call{value: claimData.amountSpentInWeis}("");
        require(sent, "Fail send refund");

        emit Refund(_battleId, claimData.amountSpentInWeis, msg.sender);
    }

    /**
     * @notice This method allows the operator to transfer remaining funds to the treasuryAddress for a specified battle.
     * @param _battleId Specifies the ID of the battle
     * @dev After 30 days have passed since a battle was canceled, the operator can transfer any remaining funds to the treasuryAddress.
     */
    function transferRemainingFunds(uint256 _battleId) external onlyOperator {
        BattleStruct storage battle = battles[_battleId];
        require(battle.status == Status.Cancelled, "Wrong status");
        require(block.timestamp > battle.cancellingDate + 30 days, "claim too soon");

        battle.status = Status.Cancelled;

        (bool sent, ) = treasuryAddress.call{value: battle.amountCollected}("");
        require(sent, "Fail send Eth to TW");

        emit RemainingFundsTransferred(_battleId, battle.amountCollected);

        battle.amountCollected = 0;
    }

    /**
     * @param _battleId Id of the battle
     * @return array of entries bought for that particular battle
     */
    function getEntries(uint256 _battleId) external view returns (Entries[] memory) {
        return entriesList[_battleId];
    }

    /**
     * @param _battleId Id of the battle
     * @param _player wallet of the player
     * @return Claims data of the player on that battle
     */
    function getClaimData(uint256 _battleId, address _player) external view returns (ClaimData memory) {
        return claimsData[keccak256(abi.encode(_player, _battleId))];
    }

    /**
     * @notice This method returns whether or not a user can buy entries based on their ownership of an NFT from a required collection.
     * This method checks if a player can buy entries for a battle based on whether they own an NFT from a required collection.
     * @param _player: The address of the player
     * @param _battleId: The ID of the battle
     * @param _collection: The address of the required collection (if any)
     * @param _tokenIdUsed: The ID of the token from the required collection that the player claims to own and wants to use in the battle
     * Returns a boolean indicating if the player can buy entries and a string explaining why they cannot (if applicable)
     */
    function playerHasRequiredNFTs(
        address _player,
        uint256 _battleId,
        address _collection,
        uint256 _tokenIdUsed
    ) external view returns (bool canBuy, string memory cause) {
        BattleStruct memory battle = battles[_battleId];

        // if the battle requires an nft
        if (battle.nftCollectionWhitelist.length > 0) {
            bool hasRequiredCollection = false;
            for (uint256 i = 0; i < battle.nftCollectionWhitelist.length; i++) {
                if (battle.nftCollectionWhitelist[i] == _collection) {
                    hasRequiredCollection = true;
                    break;
                }
            }
            if (hasRequiredCollection == false) return (false, "Not in required collection");

            IERC721 requiredNFT = IERC721(_collection);
            if (requiredNFT.ownerOf(_tokenIdUsed) != _player) return (false, "Not the owner of tokenId");
            bytes32 hashRequiredNFT = keccak256(abi.encode(_collection, _battleId, _tokenIdUsed));
            // check the tokenId has not been using yet in the battle, to avoid abuse
            if (requiredNFTWallets[hashRequiredNFT] != _player) return (false, "tokenId used");
        }

        return (true, "");
    }

    //------------------------- Setter Functions -------------------------------- //

    /**
     * @notice Sets the treasury address
     * @param _treasuryAddress The new treasury address
     */
    function setTreasuryAddress(address payable _treasuryAddress) external onlyOwner {
        require(_treasuryAddress != address(0), "Cannot be zero address");
        treasuryAddress = _treasuryAddress;
    }

    /**
     * @notice Sets the fund manager address
     * @param _fundManaderAddress The new treasury address
     */
    function setFundManagerAddress(address _fundManaderAddress) external {
        fundManaderAddress = _fundManaderAddress;
    }

    /**
     * @notice Sets the operator address
     * @param _operatorAddress The new operator address
     */
    function setOperatorAddress(address _operatorAddress) external onlyOwner {
        require(_operatorAddress != address(0), "Cannot be zero address");
        operatorAddress = _operatorAddress;
    }

    /**
     * @notice Sets the injector address
     * @param _injectorAddress The new injector address
     */
    function setInjectorAddress(address _injectorAddress) external onlyOwner {
        require(_injectorAddress != address(0), "Cannot be zero address");
        injectorAddress = _injectorAddress;
    }

    /**
     * @notice Sets the stakers' reward in basis points (BPS)
     * @param _stakersRewardBps The new stakers' reward in BPS
     */
    function setStakersReward(uint256 _stakersRewardBps) external onlyOwner {
        stakersReward = _stakersRewardBps;
        emit StakersRewardChanged(_stakersRewardBps);
    }

    /**
     * @dev Sets the stakers address to a new address.
     * @param _stakersAddress The new stakers address.
     */
    function setStakersAddress(address payable _stakersAddress) external onlyOwner {
        require(_stakersAddress != address(0), "Cannot be zero address");
        stakersAddress = _stakersAddress;
    }

    //------------------------- Getter Functions -------------------------------- //

    /**
     * @notice Gets prices for a battle
     * @param _battleId The ID of the battle to get prices for
     */
    function getPrices(uint256 _battleId) external view returns (PriceStructure[5] memory _prices) {
        _prices = prices[_battleId];
    }

    /**
     * @dev Returns the required NFT wallet for a given required NFT hash.
     * @param _requiredNFTHash The required NFT hash.
     * @return _address The required NFT wallet.
     */
    function getRequiredNFTWallet(bytes32 _requiredNFTHash) external view returns (address _address) {
        _address = requiredNFTWallets[_requiredNFTHash];
    }

    /**
     * @dev Returns the weekly jackpot battle for a given jackpot battle ID.
     * @param _jackpotBattleId The jackpot battle ID.
     * @return _jackpotBattle The weekly jackpot battle data structure.
     */
    function getWeeklyJackpotBattle(
        uint256 _jackpotBattleId
    ) external view returns (WeeklyJackpot memory _jackpotBattle) {
        _jackpotBattle = weeklyJackpotBattles[_jackpotBattleId];
    }

    /**
     * @dev Returns whether or not a free entry has been claimed for a given battle ID and user address.
     * @param _battleId The battle ID.
     * @param _user The user's address.
     * @return _claimed Whether or not the free entry has been claimed by the user for that battle ID.
     */
    function getIsFreeEntryClaimed(uint256 _battleId, address _user) external view returns (bool _claimed) {
        _claimed = isDailyFreeEntryClaimed[_battleId][_user];
    }

    /**
     * @dev Returns the weekly free entries data structure for a given jackpot battle ID and user address.
     * @param _jackpotBattleId The jackpot battle ID.
     * @param _user The user's address.
     * @return _freeEntries FreeEntries memory data structure containing information about free entries and whether they have been claimed or not.
     */
    function getWeeklyFreeEntries(
        uint256 _jackpotBattleId,
        address _user
    ) external view returns (FreeEntries memory _freeEntries) {
        _freeEntries = weeklyFreeEntries[_jackpotBattleId][_user];
    }

    /**
     * @notice Returns entries list for a given battle ID
     * @param _battleId The ID of the battle to retrieve entries for
     * @return _entries An array of Entries representing entries for the given battle ID
     */
    function getEntriesList(uint256 _battleId) external view returns (Entries[] memory _entries) {
        _entries = entriesList[_battleId];
    }

    /**
     * @notice Returns battle info for a given Chainlink request ID
     * @param _requestId The Chainlink request ID to retrieve battle info for
     * @return _battleInfo A BattleInfo struct representing the battle info for the given Chainlink request ID
     */
    function getChainlinkBattleInfo(bytes32 _requestId) external view returns (BattleInfo memory _battleInfo) {
        _battleInfo = chainlinkBattleInfo[_requestId];
    }

    /**
     * @notice Checks if a player is blacklisted
     * @param _player The address of the player to check blacklist status for
     * @return A boolean indicating if the player is blacklisted or not
     */
    function isBlackListed(address _player) public view returns (bool) {
        return blackListManager.isBlackListed(_player);
    }

    /**
     * @notice Checks if a player has reached max entries for a given battle and amount of entries
     * @param _player The address of the player to check max entries status for
     * @param _battleId The ID of the battle to check max entries status for
     * @param _amountOfEntries The amount of entries to check max entries status with
     * @return A boolean indicating if the player has reached max entries or not
     */
    function playerReachedMaxEntries(
        address _player,
        uint256 _battleId,
        uint256 _amountOfEntries
    ) external view returns (bool) {
        BattleStruct memory battle = battles[_battleId];

        // If there are no maximum number of entries set, return false.
        if (battle.maxEntries == 0) {
            return false;
        }

        bytes32 hash = keccak256(abi.encode(_player, _battleId));

        // Check there are enough entries left for this particular user.
        return (claimsData[hash].numEntriesPerUser + _amountOfEntries > battle.maxEntries);
    }

    /**
     * 	@notice Returns data about a specific Battle by its id.
     * 	@param 	_battleId	The id number associated with this specific Battle.
     * 	@return	battle	A struct containing all data about this specific Battle.
     */
    function getBattle(uint256 _battleId) external view returns (BattleStruct memory battle) {
        battle = battles[_battleId];
    }

    function getBattles() external view returns (BattleStruct[] memory _battles) {
        _battles = battles;
    }
}
